
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

// Controls:
// KEY[2]: reset the system.
// KEY[3]: Run the autofocus system.
// SW[9]: Choose between full and central auto-focus, plus yellow rectangle.

`include "VGA_Controller/VGA_Param.h"
`include "common.sv"

module DE1_SOC_D8M_RTL(
	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		    [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	output logic [6:0] HEX0, HEX1, HEX2, HEX3, HEX4, HEX5,
	output logic [9:0] LEDR,
	inout PS2_CLK, PS2_DAT,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// GPIO_1, GPIO_1 connect to D8M-GPIO //////////
	output 		          		CAMERA_I2C_SCL,
	inout 		          		CAMERA_I2C_SDA,
	output		          		CAMERA_PWDN_n,
	output		          		MIPI_CS_n,
	inout 		          		MIPI_I2C_SCL,
	inout 		          		MIPI_I2C_SDA,
	output		          		MIPI_MCLK,
	input 		          		MIPI_PIXEL_CLK,
	input 		     [9:0]		MIPI_PIXEL_D,
	input 		          		MIPI_PIXEL_HS,
	input 		          		MIPI_PIXEL_VS,
	output		          		MIPI_REFCLK,
	output		          		MIPI_RESET_n
);

//=============================================================================
// Added code to insert Filter.sv into the output path
//=============================================================================
	// The signals from the system to the filter.
	wire		          		pre_VGA_BLANK_N;
	wire		     [7:0]		pre_VGA_B;
	wire		     [7:0]		pre_VGA_G;
	wire		          		pre_VGA_HS;
	wire		     [7:0]		pre_VGA_R;
	wire		          		pre_VGA_SYNC_N;
	wire		          		pre_VGA_VS;

	assign VGA_BLANK_N = pre_VGA_BLANK_N;
	assign VGA_HS = pre_VGA_HS;
	assign VGA_SYNC_N = pre_VGA_SYNC_N;
	assign VGA_VS = pre_VGA_VS;

//=============================================================================
// REG/WIRE declarations
//=============================================================================


wire	[15:0]SDRAM_RD_DATA;
wire			DLY_RST_0;
wire			DLY_RST_1;
wire			DLY_RST_2;

wire			SDRAM_CTRL_CLK;
wire        D8M_CK_HZ ;
wire        D8M_CK_HZ2 ;
wire        D8M_CK_HZ3 ;

wire [7:0] RED   ;
wire [7:0] GREEN  ;
wire [7:0] BLUE 		 ;
wire [12:0] VGA_H_CNT;
wire [12:0] VGA_V_CNT;

wire        READ_Request ;
wire 	[7:0] B_AUTO;
wire 	[7:0] G_AUTO;
wire 	[7:0] R_AUTO;
wire        RESET_N  ;

wire        I2C_RELEASE ;
wire        AUTO_FOC ;
wire        CAMERA_I2C_SCL_MIPI ;
wire        CAMERA_I2C_SCL_AF;
wire        CAMERA_MIPI_RELAESE ;
wire        MIPI_BRIDGE_RELEASE ;

wire        LUT_MIPI_PIXEL_HS;
wire        LUT_MIPI_PIXEL_VS;
wire [9:0]  LUT_MIPI_PIXEL_D  ;
wire        MIPI_PIXEL_CLK_;
wire [9:0]  PCK;
//=======================================================
// Structural coding
//=======================================================
//--INPU MIPI-PIXEL-CLOCK DELAY
CLOCK_DELAY  del1(  .iCLK (MIPI_PIXEL_CLK),  .oCLK (MIPI_PIXEL_CLK_ ) );


assign LUT_MIPI_PIXEL_HS=MIPI_PIXEL_HS;
assign LUT_MIPI_PIXEL_VS=MIPI_PIXEL_VS;
assign LUT_MIPI_PIXEL_D =MIPI_PIXEL_D ;

//------UART OFF --
assign UART_RTS =0;
assign UART_TXD =0;
//------HEX OFF --
//assign HEX2           = 7'h7F;
//assign HEX3           = 7'h7F;
//assign HEX4           = 7'h7F;
//assign HEX5           = 7'h7F;

//------ MIPI BRIGE & CAMERA RESET  --
assign CAMERA_PWDN_n  = 1;
assign MIPI_CS_n      = 0;
assign MIPI_RESET_n   = RESET_N ;

//------ CAMERA MODULE I2C SWITCH  --
assign I2C_RELEASE    = CAMERA_MIPI_RELAESE & MIPI_BRIDGE_RELEASE;
assign CAMERA_I2C_SCL =( I2C_RELEASE  )?  CAMERA_I2C_SCL_AF  : CAMERA_I2C_SCL_MIPI ;

//----- RESET RELAY  --
RESET_DELAY			u2	(
							.iRST  ( ~MASTER_RESET ),
                     .iCLK  ( CLOCK2_50 ),
							.oRST_0( DLY_RST_0 ),
							.oRST_1( DLY_RST_1 ),
							.oRST_2( DLY_RST_2 ),
						   .oREADY( RESET_N)

						);

//------ MIPI BRIGE & CAMERA SETTING  --
MIPI_BRIDGE_CAMERA_Config    cfin(
                      .RESET_N           ( RESET_N ),
                      .CLK_50            ( CLOCK2_50 ),
                      .MIPI_I2C_SCL      ( MIPI_I2C_SCL ),
                      .MIPI_I2C_SDA      ( MIPI_I2C_SDA ),
                      .MIPI_I2C_RELEASE  ( MIPI_BRIDGE_RELEASE ),
                      .CAMERA_I2C_SCL    ( CAMERA_I2C_SCL_MIPI ),
                      .CAMERA_I2C_SDA    ( CAMERA_I2C_SDA ),
                      .CAMERA_I2C_RELAESE( CAMERA_MIPI_RELAESE )
             );

//------MIPI / VGA REF CLOCK  --
pll_test pll_ref(
	                   .inclk0 ( CLOCK3_50 ),
	                   .areset ( MASTER_RESET   ),
	                   .c0( MIPI_REFCLK    ) //20Mhz

    );

//------MIPI / VGA REF CLOCK  -
VIDEO_PLL pll_ref1(
	                   .inclk0 ( CLOCK2_50 ),
	                   .areset ( MASTER_RESET ),
	                   .c0( VGA_CLK )        //25 Mhz
    );
//------SDRAM CLOCK GENNERATER  --
sdram_pll u6(
		               .areset( 0 ) ,
		               .inclk0( CLOCK_50 ),
		               .c1    ( DRAM_CLK ),       //100MHZ   -90 degree
		               .c0    ( SDRAM_CTRL_CLK )  //100MHZ     0 degree

);

//------SDRAM CONTROLLER --
Sdram_Control	   u7	(	//	HOST Side
								 .RESET_N     ( ~MASTER_RESET ),
								 .CLK         ( SDRAM_CTRL_CLK ) ,
								 //	FIFO Write Side 1
								 .WR1_DATA    ( LUT_MIPI_PIXEL_D[9:0] ),
								 .WR1         ( LUT_MIPI_PIXEL_HS & LUT_MIPI_PIXEL_VS ) ,

								 .WR1_ADDR    ( WR1_ADDR ),
								 .WR1_MAX_ADDR(WR1_MAX_ADDR),
								 .WR1_LENGTH  ( 256 ) ,
								 .WR1_LOAD    ( !DLY_RST_0 ),
								 .WR1_CLK     ( MIPI_PIXEL_CLK_),

								 //	FIFO Read Side 1
								 .RD1_DATA    ( SDRAM_RD_DATA[9:0] ),
								 .RD1         ( READ_Request ),
								 .RD1_ADDR    ( RD1_ADDR ),
								 .RD1_MAX_ADDR( RD1_MAX_ADDR ),
								 .RD1_LENGTH  ( 256  ),
								 .RD1_LOAD    ( !DLY_RST_1 ),
								 .RD1_CLK     ( VGA_CLK ),

								 //	SDRAM Side
								 .SA          ( DRAM_ADDR ),
								 .BA          ( DRAM_BA ),
								 .CS_N        ( DRAM_CS_N ),
								 .CKE         ( DRAM_CKE ),
								 .RAS_N       ( DRAM_RAS_N ),
								 .CAS_N       ( DRAM_CAS_N ),
								 .WE_N        ( DRAM_WE_N ),
								 .DQ          ( DRAM_DQ ),
								 .DQM         ( DRAM_DQM  )
);

logic [22:0] WR1_ADDR = 0, WR1_MAX_ADDR = 640 * 480,
				 RD1_ADDR = 0, RD1_MAX_ADDR = 640 * 480;

/*
assign WR1_ADDR     = SW[8] ? (1*640*480) : (0);
assign WR1_MAX_ADDR = SW[8] ? (2*640*480) : (640*480);
assign RD1_ADDR     = 0;
assign RD1_MAX_ADDR = 640 * 480;
*/

// Picture taking logic

logic MASTER_RESET;
logic picture_reset;

assign WR1_ADDR     = take_picture ? (2*640*480) : (0);
assign WR1_MAX_ADDR = take_picture ? (3*640*480) : (640*480);
assign RD1_ADDR     = 0;
assign RD1_MAX_ADDR = 640 * 480;

enum {live, pic} ps, ns;

always_comb begin
	case(ps)
		live: begin
			picture_reset = 0;
			if (take_picture) ns = pic;
			else ns = ps;
		end
		pic: begin
			if (take_picture) begin
				ns = ps;
				picture_reset = 0;
			end
			else begin
				ns = live;
				picture_reset = 1;
			end
		end
	endcase
end

always_ff @(posedge CLOCK2_50) begin
	if (MASTER_RESET) ps <= live;
	else ps <= ns;
end

assign MASTER_RESET = picture_reset || (~KEY[2]);//(SW[7] && ~take_picture);
/*
always_comb begin
	if (~take_picture) begin
		RD1_ADDR     = 0 * 640 * 480;
		RD1_MAX_ADDR = 1 * 640 * 480;
		WR1_ADDR     = 0 * 640 * 480;
		WR1_MAX_ADDR = 1 * 640 * 480;
	end
	else begin
		RD1_ADDR     = 0 * 640 * 480;
		RD1_MAX_ADDR = 1 * 640 * 480;
		WR1_ADDR     = 2 * 640 * 480;
		WR1_MAX_ADDR = 3 * 640 * 480;
	end
end
*/
//------ CMOS CCD_DATA TO RGB_DATA --

RAW2RGB_J				u4	(
							.RST          ( pre_VGA_VS ),
							.iDATA        ( SDRAM_RD_DATA[9:0] ),

							//-----------------------------------
                     .VGA_CLK      ( VGA_CLK ),
                     .READ_Request ( READ_Request ),
                     .VGA_VS       ( pre_VGA_VS ),
							.VGA_HS       ( pre_VGA_HS ),

							.oRed         ( RED  ),
							.oGreen       ( GREEN),
							.oBlue        ( BLUE )


							);
//------AOTO FOCUS ENABLE  --
AUTO_FOCUS_ON  vd(
                      .CLK_50      ( CLOCK2_50 ),
                      .I2C_RELEASE ( I2C_RELEASE ),
                      .AUTO_FOC    ( AUTO_FOC )
               ) ;


//------AOTO FOCUS ADJ  --
FOCUS_ADJ adl(
                      .CLK_50        ( CLOCK2_50 ) ,
                      .RESET_N       ( I2C_RELEASE ),
                      .RESET_SUB_N   ( I2C_RELEASE ),
                      .AUTO_FOC      ( KEY[3] & AUTO_FOC ),
                      .SW_Y          ( 0 ),
                      .SW_H_FREQ     ( 0 ),
                      .SW_FUC_LINE   ( SW[9] ),
                      .SW_FUC_ALL_CEN( SW[9] ),
                      .VIDEO_HS      ( pre_VGA_HS ),
                      .VIDEO_VS      ( pre_VGA_VS ),
                      .VIDEO_CLK     ( VGA_CLK ),
		                .VIDEO_DE      (READ_Request) ,
                      .iR            ( R_AUTO ),
                      .iG            ( G_AUTO ),
                      .iB            ( B_AUTO ),
                      .oR            ( pre_VGA_R ) ,
                      .oG            ( pre_VGA_G ) ,
                      .oB            ( pre_VGA_B ) ,

                      .READY         ( READY ),
                      .SCL           ( CAMERA_I2C_SCL_AF ),
                      .SDA           ( CAMERA_I2C_SDA )
);

//------VGA Controller  --

VGA_Controller		u1	(	//	Host Side
							 .oRequest( READ_Request ),
							 .iRed    ( RED    ),
							 .iGreen  ( GREEN  ),
							 .iBlue   ( BLUE   ),

							 //	VGA Side
							 .oVGA_R  ( R_AUTO[7:0] ),
							 .oVGA_G  ( G_AUTO[7:0] ),
							 .oVGA_B  ( B_AUTO[7:0] ),
							 .oVGA_H_SYNC( pre_VGA_HS ),
							 .oVGA_V_SYNC( pre_VGA_VS ),
							 .oVGA_SYNC  ( pre_VGA_SYNC_N ),
							 .oVGA_BLANK ( pre_VGA_BLANK_N ),
							 //	Control Signal
							 .iCLK       ( VGA_CLK ),
							 .iRST_N     ( DLY_RST_2 ),
							 .H_Cont     ( VGA_H_CNT ),
						    .V_Cont     ( VGA_V_CNT )
		);

//--LED DISPLAY--
CLOCKMEM  ck1 ( .CLK(VGA_CLK )   ,.CLK_FREQ  (25000000  ) , . CK_1HZ (D8M_CK_HZ   )  )        ;//25MHZ
CLOCKMEM  ck2 ( .CLK(MIPI_REFCLK   )   ,.CLK_FREQ  (20000000   ) , . CK_1HZ (D8M_CK_HZ2  )  ) ;//20MHZ
CLOCKMEM  ck3 ( .CLK(MIPI_PIXEL_CLK_)   ,.CLK_FREQ  (25000000  ) , . CK_1HZ (D8M_CK_HZ3  )  )  ;//25MHZ


//assign LEDR = { D8M_CK_HZ ,D8M_CK_HZ2,D8M_CK_HZ3 ,5'h0,CAMERA_MIPI_RELAESE ,MIPI_BRIDGE_RELEASE  } ;

localparam WIDTH=640;
localparam HEIGHT=480;

// Inter-module signals
logic [COLOR_WIDTH-1:0] current_color;
logic [2:0] current_layer;
// VGA I/O
logic vga_read_request;
logic [7:0] vga_r, vga_g, vga_b;
logic [$clog2(WIDTH)-1:0] request_x;
logic [$clog2(HEIGHT)-1:0] request_y;
// Cursor renderer I/O
logic cursor_left, cursor_right;
logic [$clog2(WIDTH)-1:0] cursor_x;
logic [$clog2(HEIGHT)-1:0] raw_cursor_y, cursor_y;
logic [COLOR_WIDTH-1:0] cursor_color;
// Freehand tool I/O
logic [$clog2(WIDTH)-1:0] tool_x;
logic [$clog2(HEIGHT)-1:0] tool_y;
logic [COLOR_WIDTH-1:0] tool_color;
// Drawing canvas I/O
logic [COLOR_WIDTH-1:0] canvas1_color, canvas2_color, canvas3_color, canvas4_color;
// Terasic camera I/O

// Filtered signals
logic reset;
logic canvas1_visible, canvas2_visible, canvas3_visible, canvas4_visible;
logic cursor_visible;
logic layer_toggle;
logic take_picture;
logic ps2_start;

// NOTE: Using these subtractions will violate timing violations too far so
// that VGA will no longer work.
//assign request_x = $clog2(WIDTH)'(VGA_H_CNT - X_START);
//assign request_y = $clog2(HEIGHT)'(VGA_V_CNT - Y_START);
assign request_x = $clog2(WIDTH)'(VGA_H_CNT);
assign request_y = $clog2(HEIGHT)'(VGA_V_CNT);

// Turn off unwanted hex displays
assign HEX1 = 7'hFF;
assign HEX2 = 7'hFF;
assign HEX3 = 7'hFF;
assign HEX4 = 7'hFF;
assign HEX5 = 7'hFF;

// Metastability filters
metastability_filter reset_filter(
	.clk(CLOCK_50), .reset(1'b0), .direct_in(~KEY[3]), .filtered_out(reset));
metastability_filter ps2_start_filter(
	.clk(CLOCK_50), .reset, .direct_in(~KEY[2]), .filtered_out(ps2_start));
metastability_filter layer_toggle_filter(
	.clk(CLOCK_50), .reset, .direct_in(~KEY[0]), .filtered_out(layer_toggle));
metastability_filter cursor_visible_filter(
	.clk(CLOCK_50), .reset, .direct_in(SW[0]), .filtered_out(cursor_visible));
metastability_filter frame1_visible_filter(
	.clk(CLOCK_50), .reset, .direct_in(SW[1]), .filtered_out(canvas1_visible));
metastability_filter frame2_visible_filter(
	.clk(CLOCK_50), .reset, .direct_in(SW[2]), .filtered_out(canvas2_visible));
//metastability_filter take_picture_filter(
//	.clk(CLOCK_50), .reset, .direct_in(SW[8]), .filtered_out(take_picture));
assign take_picture = SW[8];

// Cursor logic attachments
color_selector select_color(
	.clk(CLOCK_50), .reset, .toggle(cursor_right), .color(current_color));
layer_selector select_layer(
	.clk(CLOCK_50), .reset, .toggle(layer_toggle), .layer(current_layer));
freehand_tool #(.WIDTH(WIDTH), .HEIGHT(HEIGHT)) tool_freehand(
	.clk(CLOCK_50), .reset, .enable(cursor_left), .cursor_x, .cursor_y, .input_color(current_color),
	.pixel_x(tool_x), .pixel_y(tool_y), .pixel_color(tool_color));
cursor_renderer #(.WIDTH(WIDTH), .HEIGHT(HEIGHT)) cursor_drawer(
	.clk(CLOCK_50), .reset, .cursor_x, .cursor_y, .current_color,
	.request_x, .request_y, .render_color(cursor_color));

// Drawing canvases
drawing_canvas #(.WIDTH(WIDTH), .HEIGHT(HEIGHT)) canvas1(
	.clk(CLOCK_50), .enable(current_layer == 1 && canvas1_visible),
	.tool_x, .tool_y, .tool_color,
	.pixel_x(request_x), .pixel_y(request_y), .pixel_color(canvas1_color));
drawing_canvas #(.WIDTH(WIDTH), .HEIGHT(HEIGHT)) canvas2(
	.clk(CLOCK_50), .enable(current_layer == 2 && canvas2_visible),
	.tool_x, .tool_y, .tool_color,
	.pixel_x(request_x), .pixel_y(request_y), .pixel_color(canvas2_color));
assign canvas3_color = COLOR_NONE;
assign canvas3_visible = 0;
assign canvas4_color = COLOR_NONE;
assign canvas4_visible = 0;

// Drawing I/O to VGA I/O
compositor #(.WIDTH(WIDTH), .HEIGHT(HEIGHT)) composer(
	.camera_r(pre_VGA_R), .camera_g(pre_VGA_G), .camera_b(pre_VGA_B),
	.cursor_color, .cursor_visible,
	.canvas1_color, .canvas1_visible,
	.canvas2_color, .canvas2_visible,
	.canvas3_color, .canvas3_visible,
	.canvas4_color, .canvas4_visible,
	.render_r(VGA_R), .render_g(VGA_G), .render_b(VGA_B));

// Peripheral attachments
ps2 #(.WIDTH(WIDTH), .HEIGHT(HEIGHT), .HYSTERESIS(2), .BIN(5)) ps2_mouse(
	.CLOCK_50, .start(ps2_start), .reset, .PS2_CLK, .PS2_DAT,
	.button_left(cursor_left), .button_middle(), .button_right(cursor_right),
	.bin_x(cursor_x), .bin_y(raw_cursor_y));
// For ensuring mouse enables
assign LEDR[9] = cursor_left;
assign LEDR[8] = cursor_right;
// Invert y coordinates
assign cursor_y = $clog2(HEIGHT)'(HEIGHT-1) - $clog2(HEIGHT)'(raw_cursor_y);

// Misc board I/O attachments
seg7 layer_display(
	.hex({1'b0, current_layer}), .out(HEX0));
endmodule
